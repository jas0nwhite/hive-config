package org.hnl.hive.cfg.matlab

import org.hnl.hive.cfg.TreatmentConfig
import org.hnl.matlab.M._
import org.hnl.matlab.MExp
import org.hnl.matlab.MExp._

/**
 * TreatementCfgClass
 * <p>
 * Created on Mar 1, 2016.
 * <p>
 *
 * @author Jason White
 */
case class TreatementCfgClass(cfg: TreatmentConfig) extends MExp {

  protected val treatmentDef =
    ClassProps().attribs("Constant")
      .%(
        "",
        "treatment definition",
        ""
      )
      .+(
        'name %=% cfg.name,
        'trainingSetId %=% cfg.trainingSetId.toInt,
        'trainingStyleId %=% cfg.trainingStyleId.toInt,
        'clusterStyleId %=% cfg.clusterStyleId.toInt,
        'alphaSelectId %=% cfg.alphaSelectId.toInt,
        'muSelectId %=% cfg.muSelectId.toInt
      )

  protected val treatmentDirs =
    ClassProps().attribs("Constant")
      .%(
        "",
        "treatment directories",
        ""
      )
      .+(
        'projectRoot %=% cfg.projectRoot,
        'trainingPath %=% cfg.trainingPath,
        'modelPath %=% cfg.modelPath,
        'clusterPath %=% cfg.clusterPath,
        'alphaPath %=% cfg.alphaPath,
        'muPath %=% cfg.muPath
      )

  protected val targetDirs =
    ClassProps().attribs("Constant")
      .%(
        "",
        "target directories",
        ""
      )
      .+(
        'targetSourcePathList %=% CCell(cfg.targetSourcePaths: _*),
        'targetResultPathList %=% CCell(cfg.targetResultPaths: _*),
        'targetSourceList %=% makeIndexedCellArray(cfg.targetSourceList)((s: String) => Str(s))
      )

  protected val mClass =
    ClassDef("Config")
      .%(
        s"configruation information for HIVE treatment '${cfg.name}'",
        "",
        "this code was generated by scala"
      )
      .+(
        treatmentDef,
        treatmentDirs,
        targetDirs
      )

  override def toMatlab: String = mClass.toMatlab

  /*
   * INTERNAL API
   */
  def deepZip[A](ls: List[List[A]], i: Int = 0): List[List[(A, Int)]] = ls match {
    case Nil     => Nil
    case x :: xs => x.zip(Stream.from(i)) :: deepZip(xs, i + x.size)
  }

  def makeCCell[A](l: List[A])(f: A => MExp): CCell =
    CCell(l.map(f): _*)

  def deepCCell[A](ls: List[List[A]])(f: A => MExp): CCell = {
    def cellList(ll: List[List[A]]): List[CCell] = ll match {
      case Nil     => Nil
      case x :: xs => makeCCell(x)(f) :: cellList(xs)
    }

    CCell(cellList(ls): _*)
  }

  protected def makeIndexedCellArray[A](ls: List[List[A]])(f: A => MExp): CCell =
    deepCCell(deepZip(ls, 1)) { case (a, ix) => Row(ix, f(a)) }

}
